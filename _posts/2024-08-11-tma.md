---
title: 基础知识：CPU的指令集，微架构与TMA分析方法
date: 2024-08-11 14:30:40 +0800
categories: [Performance Analysis]
tags: [analysis, cpu]
math: true
---
## **指令集架构（Instruction Set Architecture，缩写为ISA）**
CPU的指令集（Instruction Set）是CPU能够理解和执行的所有指令的集合。这些指令定义了CPU可以执行的操作，包括数据处理、数据存储、数据移动、控制指令等。指令集的设计对于CPU的性能和能效有着重要影响，并且决定了软件开发者如何编写能够在该CPU上运行的程序。

简单来说，**CPU的指令集就是CPU硬件的API，代码编译后的二进制文件就是对这些API的调用**

指令集可以根据其设计哲学分为两大类：

1. **复杂指令集计算机（CISC, Complex Instruction Set Computer）**

CISC架构的CPU拥有一个包含许多指令的大指令集，其中包括执行复杂操作的单条指令。
这些指令可能需要多个周期来执行，并且每条指令的长度和执行时间可能不同。
CISC架构旨在减少程序的大小和编译器的复杂性，因为更多的工作是由硬件完成的。
代表性的CISC架构有Intel的x86架构。

2. **精简指令集计算机（RISC, Reduced Instruction Set Computer）**：**

RISC架构的CPU具有较少的指令，且每条指令尽可能简单，大多数指令在一个周期内完成。
指令通常是固定长度的，这简化了指令的解码过程，并允许更快的执行。
RISC架构旨在通过简化指令集来提高CPU性能，将更多的工作转移到软件和编译器中。
代表性的RISC架构有ARM、MIPS和RISC-V。
RISC最大的优点是能耗效率高，所以手机，平板等对能耗敏感的移动端一般使用基于RISC指令集的CPU。

CPU指令集通常包括以下类型的指令：
* **算术逻辑指令**：执行基本的算术运算（如加、减、乘、除）和逻辑运算（如与、或、非、异或）。
* **数据传输指令**：在CPU寄存器、内存和I/O端口之间移动数据。
* **控制流指令**：改变程序的执行流程，如跳转（jump）、分支（branch）和调用（call）指令。
* **字符串和字符指令**：对字符串和字符数组执行操作的专用指令。
* **浮点指令**：对浮点数进行操作的指令，通常在专用的浮点单元（FPU）中执行。
* **特殊指令**：如中断处理、系统调用、电源管理等。

指令集的设计和选择对于系统的整体性能和效率至关重要。软件开发者需要根据目标CPU的指令集来编写或编译程序，以确保程序能够正确运行。随着技术的发展，一些现代CPU可能会支持多种指令集，或者通过指令集扩展（如SIMD指令）来增强处理能力。

如今，主流 ISA 只有少数几种，其中主要包括：

| 指令集	| 类型	| 拥有者	| 主要应用 |
| --- | --- | --- | --- |
| x86	| CISC | 	Intel 和 AMD	| 个人电脑、服务器、游戏主机 |
| ARM	| RISC	| Arm	| 移动设备、嵌入式系统 |
| RISC-V	| RISC |	开放标准	| 个人电脑、服务器、嵌入式系统
| PowerPC |	CISC	| IBM |	数据中心、游戏主机
| MIPS	| RISC |	Imagination Technologies |	处理器、嵌入式系统

目前，x86依旧在服务器领域占据统治地位。但是ARM和RISC-V也在快速发展。

## **微架构（Microarchitecture）**
CPU的微架构（microarchitecture）是指实现特定指令集架构（ISA）的具体硬件设计和组织方式。微架构涉及CPU内部的组件设计、数据流、控制逻辑、流水线结构、缓存组织、执行单元和其他低级别的实现细节。微架构的设计直接影响到处理器的性能、功耗和成本。

微架构的设计会随着每一代新的CPU而变化，以包含新的技术和优化。例如，Intel的Core系列处理器经历了多个微架构的迭代，如Nehalem、Sandy Bridge、Haswell、Skylake等。AMD的处理器也有自己的微架构迭代，如Zen、Zen 2和Zen 3。

>Block diagram of a CPU Core in the Intel Skylake Microarchitecture

![skylake](/assets/images/tma/skylake.png)

微架构的改进通常旨在提高性能（如更快的执行速度、更高的IPC即每周期指令数）、降低功耗（更高的能效比）和减少芯片面积（降低成本）。设计者需要在这些目标之间进行权衡，以满足市场和应用的需求。

微架构的关键组成部分通常包括

1. 执行单元：负责执行指令集中定义的操作，如算术逻辑单元（ALU）、浮点单元（FPU）、向量处理单元（如SIMD单元）等。
2. 寄存器：存储CPU正在处理的数据和指令的结果。寄存器文件提供比内存更快的数据访问速度。
3. 流水线（Pipelining）：将指令执行过程分解为多个阶段，每个阶段由不同的硬件组件处理。这允许多个指令同时处于不同的执行阶段，从而提高吞吐量。
4. 缓存系统：包括一级缓存（L1）、二级缓存（L2）和可能的三级缓存（L3），用于存储近期访问的数据和指令，减少对主内存的访问次数。
5. 预测器：如分支预测器和预取器，用于预测程序的控制流和数据流，以减少延迟和提高流水线效率。
6. 调度和发射逻辑：决定指令的执行顺序，包括乱序执行（out-of-order execution）逻辑，以优化资源利用和提高性能。
7. 总线和接口：包括内部总线和与其他系统组件（如内存控制器、I/O接口）的连接。
8. 功耗管理：包括各种节能技术，如动态电压和频率调整（DVFS）、睡眠模式等。

微架构的改进对性能影响主要体现在以下几个方面

* IPC 提升：IPC 指的是每时钟周期执行的指令数，提高 IPC 可以显著提升 CPU 性能。微架构的改进通过优化指令执行流程等方式来实现 IPC 的提升。
* 核心频率提升：时钟速度是 CPU 的核心频率，提高时钟速度有助于提升整体性能。微架构的改进通过提高 CPU 的能效比等方式来增加时钟速度。
* 高速缓存增加：高速缓存位于 CPU 与内存之间，其容量的增加有助于提高数据获取速度，从而提高性能。微架构的改进通过增加 CPU 的高速缓存容量来实现性能的提升。

现代⼤多数 CPU 都使⽤来流⽔线的⽅式来执⾏指令，所谓的流⽔线就是把⼀个任务拆分成多个⼩任务。
* **取指**（Instruction Fetch，IF）
* **译指**（Instruction Decode，ID）
* **执行**（Execute，EXE）
* **访存**（Memory Access，MEM）
* **写回**（Write Back，WB）

理想状态下，指令流水线的状态如下：

![pipeline1](/assets/images/tma/pipeline1.png)

在指令实际执行过程中，前后指令可能存在一些依赖，例如前一条指令的输出是后面指令的输入。这时，流水线就不得不出现一些空闲等待。为了最大化硬件的使用效率，在不影响正确性的前提下，CPU不会严格按照程序中指令的顺序，来一次进行执行（EXE）任务。所以，实际流水线的状态如下：

![pipeline2](/assets/images/tma/pipeline2.png)

为了减少分支判断对指令流水线的影响，CPU还会对分支判断进行预测，并根据预测结果提前执行一些指令。如果预测正确，指令继续向下执行，否则，丢弃掉提前执行的指令。

![pipeline3](/assets/images/tma/pipeline3.png)

另外，CPU为了提高性能，会有多条流水线同时执行。

![pipeline4](/assets/images/tma/pipeline4.png)

## **TMA分析方法（Top-Down Microarchitecture）**
我们将pipeline与CPU cycle组成pipeline slots来表示在每个单位时间pipeline是否空闲。那么在特定的时间周期内，可以计算出pipeline空闲的比例。此外，犹豫流水线预测错误，导致的指令不能正常retired也会导致性能瓶颈。对于这些性能瓶颈，计算出所占用的pipeline slots，并记录原因。就可以对cpu性能进行分析。

![pipelineslots](/assets/images/tma/pipelineslots.png)

TMA（Top-down Microarchitecture Analysis）是Intel开发的一种自顶向下的对架构瓶颈分析的有效方法，可以快速准确地反映出具体的性能瓶颈，并且通过层级图和相应的百分比，让用户只需关注核心的性能瓶颈，清楚当前瓶颈对CPU性能的影响程度，这套分析方法目前应用于Intel的分析工具集VTUNE
。

这种自顶向下的性能分析方法并不会减缓目标应用在目标机器上的运行速度，并且也不会产生大量的日志数据。

![tma](/assets/images/tma/tma.png)

如图所示，性能瓶颈会按照上图所示的层级，依次进行划分。
在第一层级，TMA对于CPU有四个分类，每个分类的比重可以先简单地理解为所消耗的比重。在最“好”的情况下，Retiring的比重为100%，其余比重为0%，即其余三个分类可以理解为三类导致CPU效率不高的分类。

CPU内部可以分为前端和后端，前端主要负责取值、译码等操作，是顺序执行；后端负责接收前端的指令，并且乱序执行，顺序Retire。但是由于现在的高性能CPU，几乎都有分支预测的功能，既然是预测，必然有预测出错的情况存在。那么，一个CPU若出现性能瓶颈，那么便有可能出现在前端或者后端，也有可能是分支预测导致的。所以，TMA的第一层级中有Frontend、Backend、Speculation这三个分类，那么，为什么还有Retiring这个分类呢？在这里，Retiring分类表示的是理想状况的流水线执行比重。

![breakdown](/assets/images/tma/breakdown.png)
